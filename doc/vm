Virtual Macine Documentation

This documentation is an "on the fly" document, where I document what I do
as I'm doing it. If there ever is a mismatch between the implementation and
this document, it is the code that is wrong. Sloppy as it is, this document
is law. 

The VM is inspired by Sun's JVM as it's bytecode instruction set is easy
to understand and learn from. This is however and exercise in WRITING a
VM / compiler, so only superficial features in the JVM are studied. In
caveman terms, I watched Grok run around with a wheel and thought - "how
did he make that? I should try to make my own." And I never saw Grok or
his wheel again.

Scrap is a fully functional, imperative language. There are no objects, 
classes or advanced data structures. Data structures (similar to those
in C) is a stretch goal, but not consideered core functionality.

VARIABLE TABLES AND STACKS
The VM is stack based, so most operations modidy the contents of the stack. 
The stack is local for each method. There are also four general purpose 
registers which may contain any variable supported by the language. 
The registers will be referred to as $0, $1, $2 and $3.

The stack is private between methods. Parameters are transferred between
methods by pushing them onto the CALLED stack from the CALLING stack. The
called method defines how many parameters it requires, and that number of
elements are MOVED to the called stack. As common practice dictates, parameters
are pushed in the reverse order.


INSTRUCTION SET
This is the COMPLETE list of instructions supported by the Scrap VM. No details
of implementation is given here, but the cleverest of people may infer it 
anyways.

Note that in the case of "_X"-post fixes, "X" denotes the local variable 
register and must be replaced with a number 0-3. Parameters are prefixed
with "#". 	

Parameters can be either literal values or register references. Uness otherwise
specified (literally or implied by context), parameters must be 32 bit integer
values. A register must contain an "int" value for it to be used as an argument.
The bytecode syntax for instructions with parameters is as follows:

Instruction with a single integral parameter:
	ishl 5	# Left shift 5 bits
	ishl $0	# Left shift $0 bits (variable register 0) 

Instruction with non-integral parameters:
	fstore_0 4.32 	# Store float(4.32) in $0
	fstore_0 $1 	# Store float($1) in $0


MNEMONIC 			DESCRIPTION						STACK [before -> after]
pop 				Pop the top value from stack 	value1 -> 
copy 				Copy the top value and push it	value1 -> value1 value2
return				Return from current method		->

# Variable and stack modification for types: replace T with any of the following:
# Note that "astore" works for both object and array references.
# - i	integer (32 bit)
# - f 	float (32 bit)
# - d 	double (64 bit)
# - l 	long (64 bit)
# - c	char (8 bit)
# - b 	bool (8 bit)
Tload 	#index		Push register value with #index	-> value1
Treturn				Return stack val from method 	value1 ->
Tstore  #index		Pop stack into register #index 	value1 ->
Tpush   #literal	Push literal value to stack.	-> literal
					Not available for (T=a).

# Conversion is required to allow for cross-type arithmetics. 
f2d					float to double 				value1(f) -> value2(d)
f2l 				float to long					value1(f) -> value2(l)
f2i					float to int					value1(f) -> value2(i)
f2c 				float to char 					value1(f) -> value2(c)
f2b 				float to bool 					value1(f) -> value2(b)

d2f 				double to float					value1(d) -> value2(f)
d2l					double to long					value1(d) -> value2(l)
d2i 				double to int 					value1(d) -> value2(i)
d2c 				double to char 					value1(d) -> value2(c)
d2b 				double to bool 					value1(d) -> value2(b)

l2i 				long to int						value1(l) -> value2(i)
l2f 				long to float 					value1(l) -> value2(f)
l2d 				long to double 					value1(l) -> value2(d)
l2c 				long to char 					value1(l) -> value2(c)
l2b 				long to bool 					value1(l) -> value2(b)

i2l 				int to long 					value1(i) -> value2(l)
i2f 				int to float 					value1(i) -> value2(f)
i2d 				int to double 					value1(i) -> value2(d)
i2c 				int to char 					value1(i) -> value2(c)
i2b 				int to bool 					value1(i) -> value2(b)

c2i 				char to int 					value1(c) -> value2(i)
c2l 				char to long 					value1(c) -> value2(l)
c2f 				char to float 					value1(c) -> value2(f)
c2d 				char to double 					value1(c) -> value2(d)
c2b 				char to bool 					value1(c) -> value2(b)

b2i					bool to int 					value1(b) -> value2(i)
b2f					bool to float 					value1(b) -> value2(f)
b2d					bool to double 					value1(b) -> value2(d)
b2l					bool to long 					value1(b) -> value2(l)
b2c					bool to char 					value1(b) -> value2(c)

# Arithmetic operations, available with the following values for T. Both 
# operands on the stack must be of the same type. The operations are unless
# otherwise specified available with the following types for <T>:
# - f	float
# - d	double
# - i	int
# - l 	long
# - c 	char
Tadd				Add two numbers					value1 value2 -> result
Tsub 				Subtract value2 from value1 	value1 value2 -> result
Tmul 				Multiply two numbers 			value1 value2 -> result
Tdiv 				Divide value1 by value2 		value1 value2 -> result

# Integer-only operations: d and f are not valid values for T for the 
# following instructions. In all cases, both operands of the instructions 
# must be of the identical type.
Tshl				Shift left "count" times 		value1 count -> value2
Tshr 				Shift right "count" times 		value1 count -> value2
Tmod 				Remainder of value1/value2 		value1 value2 -> result
Txor 				Exclusive or two numbers 		value1 value2 -> result
Tand 				Bitwise and of two numbers 		value1 value2 -> result
Tor 				Bitwise or of two numbers 		value1 value2 -> result

# Function instruction
call #funcID		Invoke function 				-> return_value 

# Branch Instructions
# The #dest argument is a 32 bit integer, pointing to the destination 
# byte instruction. There is obviously no guarantee that the destination
# is valid. When multiple stack variables are used, they must be of the
# identical type.
branch #dest 		Branch 							->
bifnull	#dest		Branch if VALUE1 is 0 			value1 -> 
bifnotnull #dest	Branch if VALUE1 is not 0		value1 ->
bifgreater #dest	Branch if VALUE1 > VALUE2 		value1 value2 -> 
bifgreatereq #dest	Branch if VALUE1 >= VALUE2		value1 value2 ->
bifless #dest		Branch if VALUE1 < VALUE2 		value1 value2 ->
biflesseq #dest 	Branch if VALUE1 <= VALUE2		value1 value2 ->
bifequal #dest		Branch if VALUE1 == VALUE2 		value1 value2 ->
bifnotequal #dest	Branch if VALUE1 != VALUE2 		value1 value2 ->
